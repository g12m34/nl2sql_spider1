// ============================================================
// FIELD METADATA (Auto-generated from database profiling)
// ============================================================
//
// Table: state
//   state_name: Unique name identifier
//   population: Numeric field
//   area: DOUBLE field
//   country_name: Unique name identifier
//   capital: TEXT field
//   density: DOUBLE field
//
// Table: city
//   city_name: Unique name identifier
//   population: Numeric field
//   country_name: Unique name identifier
//   state_name: Unique name identifier
//
// Table: border_info
//   state_name: Unique name identifier
//   border: TEXT field
//
// Table: highlow
//   state_name: Unique name identifier
//   highest_elevation: TEXT field
//   lowest_point: TEXT field
//   highest_point: TEXT field
//   lowest_elevation: TEXT field
//
// Table: lake
//   lake_name: Unique name identifier
//   area: DOUBLE field
//   country_name: Unique name identifier
//   state_name: Unique name identifier
//
// Table: mountain
//   mountain_name: Unique name identifier
//   mountain_altitude: Numeric field
//   country_name: Unique name identifier
//   state_name: Unique name identifier
//
// Table: river
//   river_name: Unique name identifier
//   length: Numeric field
//   country_name: Unique name identifier
//   traverse: TEXT field
//

// Malloy semantic layer for: geo
// Full layer with ALL columns, primary keys, and bidirectional joins
// Database: /workspace/spider_db/spider/database/geo/geo.sqlite

// ============================================================
// BASE SOURCES (no joins - enables forward references)
// ============================================================

// state
source: state_val_base is duckdb.sql("""
  SELECT * FROM sqlite_scan('/workspace/spider_db/spider/database/geo/geo.sqlite', 'state')
""") extend {
  primary_key: state_name

  dimension:
    // State population
    state_population is population
    // State area in square miles
    state_area is area
    // Population density (people per sq mile)
    state_density is density

  measure:
    row_count is count()
    total_population is sum(population)
    avg_population is avg(population)
    max_population is max(population)
    min_population is min(population)
    total_area is sum(area)
    avg_area is avg(area)
    max_area is max(area)
    min_area is min(area)
    total_density is sum(density)
    avg_density is avg(density)
    max_density is max(density)
    min_density is min(density)
}

// city
source: city_base is duckdb.sql("""
  SELECT * FROM sqlite_scan('/workspace/spider_db/spider/database/geo/geo.sqlite', 'city')
""") extend {
  primary_key: city_name

  measure:
    row_count is count()
    total_population is sum(population)
    avg_population is avg(population)
    max_population is max(population)
    min_population is min(population)
}

// border_info
source: border_info_base is duckdb.sql("""
  SELECT * FROM sqlite_scan('/workspace/spider_db/spider/database/geo/geo.sqlite', 'border_info')
""") extend {
  primary_key: border

  measure:
    row_count is count()
}

// highlow
source: highlow_base is duckdb.sql("""
  SELECT * FROM sqlite_scan('/workspace/spider_db/spider/database/geo/geo.sqlite', 'highlow')
""") extend {
  primary_key: state_name

  measure:
    row_count is count()
}

// lake
source: lake_base is duckdb.sql("""
  SELECT * FROM sqlite_scan('/workspace/spider_db/spider/database/geo/geo.sqlite', 'lake')
""") extend {
  measure:
    row_count is count()
    total_area is sum(area)
    avg_area is avg(area)
    max_area is max(area)
    min_area is min(area)
}

// mountain
source: mountain_base is duckdb.sql("""
  SELECT * FROM sqlite_scan('/workspace/spider_db/spider/database/geo/geo.sqlite', 'mountain')
""") extend {
  primary_key: mountain_name

  measure:
    row_count is count()
    total_mountain_altitude is sum(mountain_altitude)
    avg_mountain_altitude is avg(mountain_altitude)
    max_mountain_altitude is max(mountain_altitude)
    min_mountain_altitude is min(mountain_altitude)
}

// river
source: river_base is duckdb.sql("""
  SELECT * FROM sqlite_scan('/workspace/spider_db/spider/database/geo/geo.sqlite', 'river')
""") extend {
  primary_key: river_name

  dimension:
    // River length in miles
    river_length is length
    // States the river traverses through
    traverses is traverse

  measure:
    row_count is count()
    total_length is sum(length)
    avg_length is avg(length)
    max_length is max(length)
    min_length is min(length)
}

// ============================================================
// FULL SOURCES (with joins - use these for queries)
// ============================================================

// state (with joins)
source: state_val is state_val_base extend {
  join_many: city is city_base on state_name = city.state_name
  join_many: border_info_border is border_info_base on state_name = border_info_border.border
  join_many: border_info_state_name is border_info_base on state_name = border_info_state_name.state_name
  join_many: highlow is highlow_base on state_name = highlow.state_name
  join_many: mountain is mountain_base on state_name = mountain.state_name
  join_many: river is river_base on state_name = river.traverse
}

// city (with joins)
source: city is city_base extend {
  join_one: state_val is state_val_base on state_name = state_val.state_name
}

// border_info (with joins)
source: border_info is border_info_base extend {
  join_one: border_state_val is state_val_base on border = border_state_val.state_name
  join_one: state_name_state_val is state_val_base on state_name = state_name_state_val.state_name
}

// highlow (with joins)
source: highlow is highlow_base extend {
  join_one: state_val is state_val_base on state_name = state_val.state_name
}

// lake (with joins)
source: lake is lake_base

// mountain (with joins)
source: mountain is mountain_base extend {
  join_one: state_val is state_val_base on state_name = state_val.state_name
}

// river (with joins)
source: river is river_base extend {
  join_one: state_val is state_val_base on traverse = state_val.state_name
}
